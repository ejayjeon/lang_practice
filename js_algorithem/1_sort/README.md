# JavaScript Algorithem

## 1. Selection sort (선택 정렬)
---
- 제자리 정렬 알고리즘
- 메모리가 제한적인 경우에 사용해야 성능 상의 이점이 있다

1) 주어진 리스트 중에서 최솟값을 찾는다
2) 찾은 최솟값을 리스트 맨 앞에 위치한 값과 교체한다
3) 맨 처음 위치를 뺀 나머지 리스트를 1)-2) 방법으로 교체하면서 비교 정렬한다


## 2.Bubble sort (거품 정렬)
---
1) 배열의 두 수(a, b)를 선택한다
2) 두 수가 정렬되었다면 패스
3) (정렬되지 않았다면) 오름차순 정렬 시 a < b, 내림차순 정렬 시 a > b
4) 배열의 처음부터 끝까지 반복한다
5) 배열에 아무 변화가 없을 때까지 반복한다 


## 3. Heap sort (힙 정렬)
---
- 특정한 자식 노드 중에서, 자신과 비교하여, 자신보다 자식 보드가 더 크면 위치를 바꾸는 알고리즘
- 위치를 바꾼 후에도 자식이 존재하는 경우, 비교 연산을 통해 더 큰 자식과 자신의 위치를 바꾼다.
- 내림차순 정렬을 위해서는 최소 힙을 구성하고, 오름차순 정렬을 위해서는 최대 힙을 구성
- 최대 힙: 부모노드가 자식노드보다 큰 트리

1) n개의 노드에 대한 완전 이진 트리 구성
2) 루트 노트부터 부모노트, 왼쪽 자식노드, 오른쪽 자식노드 순으로 구성한다
3) 최대 힙 구성. 아래부터 루트까지 올라오며 순차적으로 정렬
4) 가장 큰 수(루트)를 가장 작은 수와 교환
5) 3과 4를 반복한다


## 4. Quick sort (퀵 정렬)
---
- 분할 / 정복 알고리즘의 하나로, 기준점을 설정하여 배열을 두 개의 부분 배열로 나누고, 각 부분 배열을 재귀적으로 정렬하는 방식

1) 리스트에서 원소 하나를 골라 피벗(pivot)으로 정한다 
    - 보통 좌측 끝, 우측 끝, 중앙의 세 값의 중위법을 이용
2) 피벗 앞에는 피벗보다 값이 작은 모든 원소들이 오고, 피벗 뒤에는 피벗보다 값이 큰 모든 원소들이 오도록, 피벗을 기준으로 리스트를 둘로 나눈다. (분할)
3) 분할된 두 개의 작은 리스트에 대해 재귀로 위의 과정을 반복한다. 
4) 재귀는 리스트의 크기가 0이나 1이 될 때까지 반복한다
5) 재귀 호출이 한 번 진행될 때마다 최소 하나의 원소는 최종적인 위치가 정해지므로, 알고리즘은 반드시 끝이 난다.



## 5. Insertion sort (삽입 정렬)
---
- 리스트의 모든 요소를 앞에서부터 차례대로, 이미 정렬된 배열 부분과 비교하여 자신의 위치를 찾아 삽입
- 배열이 길어질수록 효율이 떨어진다



## 6. LRU (Least Recently Used) 알고리즘 구현하기
---
- 가장 오랫동안 사용하지 않은 것을 제거하고, 가장 최근에 사용한 것을 상단에 추가한다.

1) 메모리의 크기가 정해지고
2) 메모리가 비어있는 상태에서 N개의 작업을 CPU가 차례로 처리할 때
3) 모든 작업이 끝난 후 캐시메모리의 상태를 가장 최근 사용된 작업부터 순차적으로 출력하는 프로그램 작성하기

> 입력 예제 <br>
> 5 <br>
> 1 2 3 2 6 2 3 5 7

> 출력 예제 <br>
> 7 5 3 2 6

```javascript
function solution_6(s, n, arr) {
  // 캐시 크기 설정 (s의 크기 만큼)
  let answer = Array.from({ length: s }, () => 0);
  arr.forEach((x) => {
    setPage(answer, x, s);
  });

  return answer;
}

function setPage(arr, page, memory) {
  let answer = arr;
  const index = arr.indexOf(page);
  // -1이면 인덱스에 없다는 의미
  // 인덱스에 있으면, 해당 페이지를 제거하고 맨 앞에 추가
  if (index !== -1) {
    answer.splice(index, page);
  } else {
    // 페이지가 캐시에 없으면? 캐시가 가득 찬 경우 가장 오래된 페이지 제거
    if (answer.length >= memory) {
      answer.pop();
    }
  }
  // 배열의 맨 앞에 페이지를 추가 (unshift)
  answer.unshift(page);
  return answer;
}
```




## 8. 이분 검색
---
- 임의의 수 N개가 입력으로 주어지면,
- N개의 수를 오름차순으로 정렬한다
- 정렬된 수 중 임의로 정한 숫자 M을 이분 검색으로, 
- 정렬된 상태에서 몇 번째에 위치해 있는지 구하는 알고리즘을 작성하기
- 중복값은 존재하지 않는다는 가정

> 입력 예제 <br>
> 8 32 <br>
> 23 87 65 12 57 32 99 81



> 출력 예제 <br>
> 3

```js
function solution_8(m, arr) {
  // 1. 오름차순 정렬
  let answer = arr.sort((a, b) => a - b);

// 왼쪽 = 0, 오른쪽 = 배열의 마지막
  let lt = 0,
    rt = answer.length - 1;

  while (lt <= rt) {
    // 중간수
    let mid = parseInt((lt + rt) / 2);

    // 배열의 중간값이, 타겟과 같은지 확인
    if (answer[mid] == m) {

      answer = mid + 1;
      break;
    } else if (answer[mid] > m) rt = mid - 1;
    else lt = mid + 1;
  }
  return answer;
}

let arr_8 = [23, 11, 87, 65, 12, 57, 32, 99, 81];
console.log(`이분 검색: ${solution_8(32, arr_8)}`);

```


## 9. 결정 알고리즘(Decision)_마구간 정하기
---
- 특정 문제에 대해 예 또는 아니오와 같은 이진 형태의 답을 결정하는 알고리즘
- 입력 데이터를 기반으로 명확하고 이진적인 결과를 도출한다
- 데이터라 정렬되어 있는 경우, 규칙 기반의 의사 결정이 필요한 경우에 주로 사용한다
- 주로 분류 문제나 탐색 문제에 사용한다


- N개의 마구간이 수직선상에 있다 (한 마구간에는 한 마리의 말만 수용 가능)
- 각 마구간은 x1, x2, x3... xN 개의 좌표를 가진다
- C 마리의 말을 마구간에 각각 배치하려고 한다. 가장 가까운 두 말의 거리가 최대가 되는 최대값을 출력하라

> 입력 예제 <br>
> 3 <br>
> 1 2 8 4 9

> 출력 예제 <br>
> 3